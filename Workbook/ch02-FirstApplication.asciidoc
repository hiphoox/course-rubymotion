Chapter 02 - First Application
==============================

Time Zone Converter App
-----------------------

Time is one of the most precious resources that we have, and for travelers around the world it's essential to keep synced between one place and another so they can accomplish goals and requirements on time.
We are going to build an application for them, so they can check their local time and the time in the place where they're traveling. The app should cover the following functionality:

- Display local time zone
- Calculate the time difference between any two time zones

First of all you'll need to create your project with ruby motion, so run the following command in your terminal:

[source, sh]
--------------------------------------
$ motion create TimeZoneConverter
--------------------------------------

And then take a look inside the directory just created:

[source, sh]
--------------------------------------
$ cd TimeZoneConverter

$ ls -F
--------------------------------------

You will see that the following files and directories have been created:

--------------------------------------
Rakefile app/ resources/ spec/
--------------------------------------

Now execute the following command to build and run the app :

[source, sh]
--------------------------------------
$ rake
--------------------------------------

If everything goes well, you will see an ugly black window. It's a humble beginning,
essentially a "hello, world" for iOS, but to quote Laozi, "a journey of a thousand miles begins with a single step."

.Empty Application
image::resources/ch02-FirstApplication/image1.png[Empty Application]

[NOTE]
Please add images to the 'resources' folder of your project. You can find them in the 'ch02-FirstApplication/resource/images' 
folder.

View Controller
~~~~~~~~~~~~~~~

The MVC (Model-View-Controller) paradigm is by now widely used and accepted as a means of
organizing applications so that views (UI elements) and models (the problem domain) remain isolated from the details of connecting
user interactions (clicks, scrolls, drags) with changes to the model, and then
communicating those changes back to the views. The latter activities become the responsibility
of the controller, or in Apple's terminology, the view controller. The UIViewController class, and its subclasses, are the standard tool to manage views in iOS applications. 

Adding a View Controller
~~~~~~~~~~~~~~~~~~~~~~~~

Open your file *app_delegate.rb* in the 'app' folder and insert the highlighted lines below into the
stub file already generated by "motion create".

[WARNING]
Interleaving insertions ahead.

["source","ruby", args="-O \"hl_lines=4 5 6\""]
---------------------------------------------------------------------------------
class AppDelegate
 
 def application(application, didFinishLaunchingWithOptions:launchOptions)
    @window = UIWindow.alloc.initWithFrame(UIScreen.mainScreen.bounds) 
    @window.rootViewController = RootViewController.alloc.init
    @window.makeKeyAndVisible 
    true
  end

end
---------------------------------------------------------------------------------

Now create a new file named *root_view_controller.rb* in the 'app' folder and add the following code:


[source, ruby]
--------------
class RootViewController < UIViewController
  
  def viewDidLoad
    view.backgroundColor = UIColor.scrollViewTexturedBackgroundColor
  end	

end
--------------

The 'viewDidLoad' method will be called when the the RootViewController's view loads, and it will then
set the background color. Let's see that in action.

Save your file and run the rake command:

[source, sh]
--------------------------------------
$ rake
--------------------------------------

You should see a gray styled view. Congratulations, you have added your first view controller. It wasn't really that hard, was it? On the other hand, this is not really a major improvement. It would be nice if it could do something a bit more exciting,
wouldn't it? For that we'll need some views.

.View Controller Added
image::resources/ch02-FirstApplication/image2.png[View Controller Added]


Now let's create a new file named *root_view_utilities.rb*, which will contain the following UI elements:

- UILabel 
- UIButton
- UITextField
- UIStepper

Each method in this file will receive the position where the UIControl should be displayed and will return the UIControl
itself. While we could have coded these methods directly into the *root_view_controller.rb* file, it is useful to group
these logically related UI methods together in a separate file. Ultimately they need to be defined on the RootViewController
class, so we'll place them in a module named 'UI_Elements' and then just 'include' them into the RootViewController class.

Another logically related group of methods have to do with getting date strings from dates, so we'll put them
in a separate file as well. We'll also put them in a module named *Time_Offset* and them 'include' them into the
RootViewController.

[NOTE]
Please add the following ruby files to the 'app' folder: *root_view_utilities.rb* and *time_offset.rb*.

Place the following code in *root_view_utilities.rb*:


[source, ruby]
--------------
module UI_Elements 

  def time_label(xPosition,yPosition)

    label = UILabel.alloc.initWithFrame(CGRectMake(xPosition,yPosition,200,50))
    label.backgroundColor = UIColor.clearColor;
    label.text = "UTC offset"
    label.textColor = UIColor.whiteColor;
    label

  end

  def select_time_zone_Button (xPosition,yPosition)
    
    button = UIButton.buttonWithType(UIButtonTypeCustom)
    button.frame = CGRectMake(xPosition,yPosition,85,73)
    button.setBackgroundImage(UIImage.imageNamed("btnSelect.png"),forState:UIControlStateNormal)
    button.setTitle("Convert",forState:UIControlStateNormal)
    button

  end


  def time_zone_text_field (xPosition,yPosition)

    textField = UITextField.alloc.initWithFrame(CGRectMake(xPosition,yPosition, 170, 30))
    textField.borderStyle = UITextBorderStyleRoundedRect
    textField.font = UIFont.systemFontOfSize(15)
    #textField.userInteractionEnabled = false

    textField

  end

  def ui_stepper (xPosition,yPosition)

    stepper = UIStepper.alloc.initWithFrame (CGRectMake(xPosition,yPosition, 30, 30))
    stepper.addTarget(self ,action: :'stepperPressed:', forControlEvents:UIControlEventValueChanged)
    stepper

  end

end
--------------

[WARNING]

Rubymotion provides some syntactic sugar so that in general we can replace code like this:
[source, ruby]
---------------------------------
button.setFrame = CGRectMake(xPosition,yPosition,85,73)
-----------------------------------
with fully equivalent and more Ruby-ish code like this:
[source, ruby]
-----------------------------------
button.frame = CGRectMake(xPosition,yPosition,85,73)
------------------------------
But there are cases where it is not possible. For instance, this:
[source, ruby]
-----------------------------------
button.setBackgroundImage(UIImage.imageNamed("btnSelect.png"),forState:UIControlStateNormal)
------------------------------
cannot be re-written as this, which won't compile:
[source, ruby]
-----------------------------------
button.backgroundImage = (UIImage.imageNamed("btnSelect.png"),forState:UIControlStateNormal)
------------------------------
The reason is that the message in this case is actually 'setBackgroundImage:forState:'. Only
in the simple cases is this syntactic sugar provided.


Place the following code in *time_offset.rb*:


[source, ruby]
--------------
module TimeOffset

  def month_year_string (date)

    format = NSDateFormatter.alloc.init
    format.dateFormat = "MMM dd, yyyy HH:mm"
    dateString = format.stringFromDate(date)

    dateString
  end

  def hour_string (date)
    format = NSDateFormatter.alloc.init
    format.dateFormat ="HH"
    dateString = format.stringFromDate(date)

    dateString
  end

  def minute_string (date)
    format = NSDateFormatter.alloc.init
    format.dateFormat = ": mm"
    dateString = format.stringFromDate(date)

    dateString
  end

end
--------------


Save your file and build the project to see that everything still compiles (although it
will still look exactly the same, i.e. no UIViews yet!)

Then open the file *root_view_controller.rb*. We now need to add our controls. Replace 'all' lines
in the file with the following:

[source, ruby]
--------------
class RootViewController < UIViewController
  
  include UI_Elements
  include TimeOffset

  def set_current_time

    calendar = NSCalendar.alloc.initWithCalendarIdentifier(NSGregorianCalendar)
    @offsetDate = NSDate.date
    components = calendar.components (NSMinuteCalendarUnit,fromDate:@offsetDate)   
    
    @stepper.value = components.minute 
    @currentTimeLabel.text = month_year_string(@offsetDate)
  end

  def set_remote_time_zone

    @remoteTimeZoneTextField.text = "Europe/Zurich"
    @remoteTimeZoneTextField.returnKeyType = UIReturnKeyDone

  end

  def set_remote_time

    convertZone = NSTimeZone.timeZoneWithName(@remoteTimeZoneTextField.text)

    formatter = NSDateFormatter.alloc.init
    formatter.setDateFormat('HH:mm')
    formatter.setTimeZone(convertZone)

    dateFormat = formatter.stringFromDate(@offsetDate)

    @convertDate = formatter.dateFromString(dateFormat)
    @remoteTimeLabel.text = "UTC "+(convertZone.secondsFromGMT/3600).to_s + "  "+ dateFormat

  end
  	  	  
  def viewDidLoad  

    @currentTimeLabel =  time_label(25,65)
    @stepper = ui_stepper (220,75)

    @remoteTimeZoneTextField = time_zone_text_field(25,185)
    @remoteTimeZoneTextField.delegate = self
    @remoteTimeLabel =  time_label(25,210)

    view.addSubview(@currentTimeLabel)
    view.addSubview(@remoteTimeZoneTextField)
    view.addSubview(@remoteTimeLabel)
    view.addSubview(@stepper)

    set_current_time
    set_remote_time_zone

    view.backgroundColor = UIColor.scrollViewTexturedBackgroundColor

  end 	

end
--------------

Run your program and you should see at the top a UILabel with your current time zone and also a UIStepper which will be useful to change the date, and finally a UITextField indicating the remote time zone, in this case Zurich. Feel free to input any other of the following known time zones:

- America/Cancun
- Asia/Tokyo
- Europe/Rome
- Pacific/Fiji

If you change the time zone, you'll notice that the keyboard does not go away. We'll fix this annoying quirk later
as a challenge at the end of this chapter.

[WARNING]
For the moment, don't click on the stepper control.


.Controls Added
image::resources/ch02-FirstApplication/image3.png[Controls Added]

Using the Interactive Console
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's stop a moment right here to see the properties of the UILabel that we just added. Without quitting the simulator, hold down the ⌘ key and hover the mouse over the simulator screen. You can see that red-bordered boxes appear when you hover over the application elements. Select the label that reads "UTC offset" and you will see, in the 
interactive console, the instance corresponding to that label printed in typical Ruby style.


---------------------------------------------------------------------------------
(#<UILabel:0x9447e60>)> 
---------------------------------------------------------------------------------

Mouse down now and the variable 'self' in the interactive console will be set to UILabel that you just selected.
Now we can display the 'text' property of the UILabel:

---------------------------------------------------------------------------------
(#<UILabel:0x9447e60>)> self.text
=> "UTC offset"
---------------------------------------------------------------------------------

Let's say that we are extremely curious and we want to know the class of the 'text' property from UILabel:

---------------------------------------------------------------------------------
(#<UILabel:0x9447e60>)> self.text.class
=> String
---------------------------------------------------------------------------------

As we would have expected, it's a String, but now what if we want to know the superclass of the 'text' property from the UILabel?

---------------------------------------------------------------------------------
(#<UILabel:0x9447e60>)> self.text.superclass
=> NSMutableString
---------------------------------------------------------------------------------

Now we can look at the String's ancestors by typing the following:

---------------------------------------------------------------------------------
(#<UILabel:0x9447e60>)> String.ancestors
=> [String, NSMutableString, NSString, Comparable, NSObject, Kernel]
---------------------------------------------------------------------------------

As you can see, some Cocoa classes (starting with "NS") occur in the inheritance chain along
with the traditional Ruby classes.

We also can see the available methods on this UILabel. Type the following in your terminal:

---------------------------------------------------------------------------------
(#<UILabel:0x9447e60>)> methods
=> [:"repl:", :quit, :help, :sessions, :accessibilityTraits, ...TRUNCATED...
---------------------------------------------------------------------------------

As you can see, there are a great many of them, but we can use the *grep* method to filter the list:

---------------------------------------------------------------------------------
(#<UILabel:0x9447e60>)> methods.grep(/class/)
=> [:singleton_class, :className, :classForPortCoder, :classForCoder, :classForKeyedArchiver, ...]
---------------------------------------------------------------------------------

To return to the main session, you can enter the following command:

---------------------------------------------------------------------------------
(#<UILabel:0x9591580>)> quit
---------------------------------------------------------------------------------

Now type "self" to be sure that you are in fact back in the main session:

---------------------------------------------------------------------------------
(main)> self            
=> main
(main)> 
---------------------------------------------------------------------------------

So far we have discovered some interesting things, but much more is possible. For instance,
we can find the instance variables of our RootViewController:

---------------------------------------------------------------------------------
(main)> RootViewController.instance_variables
=> [:__classpath__]
---------------------------------------------------------------------------------

And of course we can find out all the elements of the application:

---------------------------------------------------------------------------------
(main)> UIApplication.sharedApplication.keyWindow.rootViewController.view.subviews
=> [#<UILabel:0x95448e0>, #<UILabel:0x9544c30>, #<UIButton:0x9545110>, #<UILabel:0x9537eb0>
---------------------------------------------------------------------------------

and then see a recursive list of the elements:

---------------------------------------------------------------------------------
(main)> UIApplication.sharedApplication.keyWindow.recursiveDescription
---------------------------------------------------------------------------------

Note this output is hard to read without some doctoring, so let's fix it.

---------------------------------------------------------------------------------
(main)> output = UIApplication.sharedApplication.keyWindow.recursiveDescription; nil
	. . . . . .
(main)> output.split(/\n/).each { |line| puts line }; nil
<UIWindow: 0x9659e60; frame = (0 0; 320 480); layer = <UIWindowLayer: 0x965a050>>
   | <UIView: 0x955a7a0; frame = (0 20; 320 460); autoresize = W+H; layer = <CALayer: 0x95531f...
   |    | <UILabel: 0x954cdc0; frame = (25 65; 200 50); text = 'Jun 14, 2013 10:29'; clipsToBo...
   |    | <UITextField: 0x9548340; frame = (25 185; 170 30); text = 'Europe/Zurich'; clipsToBo...
   |    |    | <UITextFieldRoundedRectBackgroundView: 0x955bcc0; frame = (0 0; 170 30); userIn...
   |    |    |    | <UIImageView: 0x955beb0; frame = (0 0; 8 30); opaque = NO; userInteraction...
   |    |    |    | <UIImageView: 0x955bf60; frame = (8 0; 154 30); opaque = NO; userInteracti...
   |    |    |    | <UIImageView: 0x955bff0; frame = (162 0; 8 30); opaque = NO; userInteracti...
   |    |    | <UITextFieldLabel: 0x9549260; frame = (7 2; 156 19); text = 'Europe/Zurich'; cl...
   |    | <RBAnonymous8: 0x955d450; baseClass = UILabel; frame = (25 210; 200 50); text = 'UTC...
   |    | <UIStepper: 0x955b0e0; frame = (220 75; 94 27); layer = <CALayer: 0x955b1f0>>
   |    |    | <UIButton: 0x9556060; frame = (0 0; 47 27); opaque = NO; layer = <CALayer: 0x95...
   |    |    |    | <UIImageView: 0x955eb60; frame = (0 0; 47 27); clipsToBounds = YES; opaque...
   |    |    |    | <UIImageView: 0x955ec60; frame = (17 12; 13 4); clipsToBounds = YES; opaqu...
   |    |    | <UIButton: 0x954e220; frame = (47 0; 47 27); opaque = NO; layer = <CALayer: 0x9...
   |    |    |    | <UIImageView: 0x955ecf0; frame = (0 0; 47 27); clipsToBounds = YES; opaque...
   |    |    |    | <UIImageView: 0x955eda0; frame = (18 7; 13 14); clipsToBounds = YES; opaqu...
   |    |    | <UIImageView: 0x954e300; frame = (46 0; 2 27); opaque = NO; userInteractionEnab...
=> nil	
---------------------------------------------------------------------------------

Since the REPL (Read-Eval-Print-Loop) always prints the value of the last expression evaluated,
we can avoid screen clutter by introducing another statement with a ";" and then evaluating "nil".
The nil is printed, but it doesn't take up much screen space.

You can use the 'include'? method from Array to ask if a method exists:

---------------------------------------------------------------------------------
[].methods.include? :[]
=> true
---------------------------------------------------------------------------------

We can also see Objective-C methods:

---------------------------------------------------------------------------------
[].methods.include?(:'objectAtIndex:')
=> true
---------------------------------------------------------------------------------

This should give you a taste of what you can do in the interactive console.But before we move on to fleshing out our application,
let's give that stepper control that we warned you about a try. Click on it now and the app will crash.

Much output is produced, but the first line really says it all:

---------------------------------------------------------------------------------
(main)> 2013-06-14 11:29:17.721 TimeZoneConverter[11724:c07] -\
[RootViewController stepperPressed:]: unrecognized selector sent to instance 0xf7b61f0
---------------------------------------------------------------------------------

In *root_view_utilities.rb* we see this line, which tells the stepper to send the 'stepperPressed:'
message to 'self' (the RootViewController) when it is pressed:
---------------------------------------------------------------------------------
stepper.addTarget(self ,action: :'stepperPressed:', forControlEvents:UIControlEventValueChanged)
---------------------------------------------------------------------------------
but we forgot to code that method.
This mishap occurs frequently when wiring up user interfaces in Cocoa, so you shouldn't
be panicked when you see this in your own apps.


We'll address the stepper problem shortly, for now let's get back to fleshing out our application.
It’s time to add a button that shows the time for a remote time zone. Open the *root_view_controller.rb* and add the following highlighted code on your *viewDidLoadMethod*: 

Adding the Convert Button
~~~~~~~~~~~~~~~~~~~~~~~~~

[WARNING]
Interleaving insertions ahead. 

["source","ruby", args="-O \"hl_lines=10 11 17\""]
--------------
def viewDidLoad  

    @currentTimeLabel =  time_label(25,65)
    @stepper = ui_stepper (220,75)

    @remoteTimeZoneTextField = time_zone_text_field(25,185)
    @remoteTimeZoneTextField.delegate = self
    @remoteTimeLabel =  time_label(25,210)

    chooseconvertButton = select_time_zone_Button(220,120)
    chooseconvertButton.addTarget(self, action: :'set_remote_time', forControlEvents:UIControlEventTouchUpInside)

    view.addSubview(@currentTimeLabel)
    view.addSubview(@remoteTimeZoneTextField)
    view.addSubview(@remoteTimeLabel)
    view.addSubview(@stepper)
    view.addSubview(chooseconvertButton)

    set_current_time
    set_remote_time_zone

    view.backgroundColor = UIColor.scrollViewTexturedBackgroundColor

end  
--------------

Now add the following method to your *root_view_controller.rb* file:

[source, ruby]
--------------
def stepperPressed (sender)

  calendar = NSCalendar.alloc.initWithCalendarIdentifier(NSGregorianCalendar)

  components = calendar.components (NSMinuteCalendarUnit,fromDate:@offsetDate)   
  minute = components.minute

  if minute > @stepper.value
    @offsetDate = NSDate.alloc.initWithTimeInterval(-60,sinceDate:@offsetDate)
  else 
    @offsetDate = NSDate.alloc.initWithTimeInterval(60,sinceDate:@offsetDate)
  end

  components = calendar.components (NSMinuteCalendarUnit,fromDate:@offsetDate)
  @stepper.value = components.minute
  @currentTimeLabel.text = month_year_string(@offsetDate)
end
--------------

Next compile your application; you should see a big black button, don’t hesitate to try it.

.UIPicker Added
image::resources/ch02-FirstApplication/image4.png[UIPicker Added]

Styling the App
~~~~~~~~~~~~~~~

The style of our application does not reflect the adventurous spirit that it should; maybe with some small improvements we can change that.

Run the application with the rake command

[source, sh]
------------
$ rake
------------

Now you should see the REPL in your console:

[source, sh]
------------
Create ./build/iPhoneSimulator-6.0-Development/TimeZoneConverter.dSYM
Simulate ./build/iPhoneSimulator-6.0-Development/TimeZoneConverter.app
(main)>
------------

Now hold down the  ⌘ key and hover the mouse over the simulator screen. You can see a red-bordered box appears among the application elements, select the current date label and the interactive console should display the instance corresponding to that label:

[source, sh]
------------
Build ./build/iPhoneSimulator-6.0-Development
Simulate ./build/iPhoneSimulator-6.0-Development/TimeZoneConverter.app
(#<UILabel:0x956a650>)>
------------

Now it's time to make some small change to our application while it's running. Yes you read that right! Type the following in your REPL and then the Enter key:

[source, ruby]
--------------
self.font = UIFont.fontWithName("Noteworthy-Bold",size:18)
--------------
 
.UIPicker Added
image::resources/ch02-FirstApplication/image6.png[UIPicker Added]

Voilà, the font has changed, but you may not like it, so try with different fonts and sizes. Here there are some to try:

* Georgia-Italic
* MarkerFelt-Thin
* HelveticaNeue-Medium

Since the creation of the apple store there are many apps to choose from, the app store is not the wild West that it used to be, so we are going to give some personality to our app.


Early in this chapter we copied images to the resources folder of our app, but until now we've really only used
the *btnSelect.png* (and *btnSelect@2x.png*) image for our convert button. Now let's set the background of our
app so something eye-catching.
In the file *root_view_controller.rb* change the following line in your *viewDidLoad* method:

[source, ruby]
--------------
view.backgroundColor = UIColor.scrollViewTexturedBackgroundColor
--------------

for this one:
[source, ruby]
--------------
view.backgroundColor = UIColor.colorWithPatternImage(UIImage.imageNamed("bgApp.png"))
--------------

[WARNING]
Replacing code ahead.

We should add some personality to our buttons, so open your file *root_view_uitilities.rb* and replace the *time_label* method: 

[source, ruby]
--------------
def time_label(xPosition,yPosition)
  label = UILabel.alloc.initWithFrame(CGRectMake(xPosition,yPosition,200,50))
  label.backgroundColor = UIColor.clearColor;
  label.text = "UTC offset"
  label.textColor = UIColor.whiteColor;
  label.font = UIFont.fontWithName("Noteworthy-Bold",size:18)
  label
end
-------------

Then run the app again with the rake command. This time it's got a lot more sex appeal.


.Stylish App
image::resources/ch02-FirstApplication/image7.png[Stylish App]

Challenge - Dismiss KeyBoard
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You may have tried to press the "Done" button on the keyboard only to find that nothing happens.
You should blame Apple for this, but don't worry, they do give you a way to take care of it
by providing a delegate method to be called when the "Done" button A.K.A (Return key) is pressed.
You only have to add the following method
to your *root_view_controller.rb* file.

[source, ruby]
--------------
def textFieldShouldReturn (textField)
  @remoteTimeZoneTextField.resignFirstResponder
end
--------------

Challenge - Dismiss on touch
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

How is it that fancy apps dismiss the keyboard when any other area is touched ? As you may have
guessed, it's not automatic. You'll have to add a "Tap Gesture Recognizer" 
to sense when any other area of the screen is touched. Add the following lines, which add a tap gesture 
to the RootViewController view, to the top of the *viewDidLoad* method in *root_view_controller.rb*:

--------------
singleTap = UITapGestureRecognizer.alloc.initWithTarget(self, action: :'handleSingleTap')
self.view.addGestureRecognizer(singleTap)
--------------
Then add this method to the same file.
---------------------------------------------------------------------------------
def handleSingleTap
  @remoteTimeZoneTextField.resignFirstResponder
end
---------------------------------------------------------------------------------
Build again and try it out.

So it's up to you to implement the *singleTap* method to dismiss the keyboard when the screen is touched.
