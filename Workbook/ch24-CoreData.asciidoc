Chapter 24 - Core Data
======================

Core Data is an object graph manager with lifecycle, searching and persistence features. What these means is that is a object manager that will allow us to create and destroy objects, make and validate relationships between them and finally search for specific objects using predicates. 

Contrary as many think Core Data is not a database and the best example of it is that Core Data can be used totally in-memory without any form of persistence. But of course the main feature of Core Data is the persistence so lets take a little look on the differences between it and a database:

. The primary function of Core Data is object management, the primary function of a Database is storing and fetching data

. Core Data works using objects stored in memory (Which can be persisted on disk), which can have behavior and attributes. Instead of the database than only stores the plain data

. The databases can work on the data without load it into memory, Core Data can not do it: The objects to manipulate must be loaded first into memory before we can alter them

. Core Data requires a save process before it write all the changes (New, Alter or Deleted objects) into disk

. The data integrity and relationships are managed in the database by using features like "unique" keys. In Core Data they are managed by business logic inside our app


IMPORTANT: Core Data is not fully multi-threaded, if you have the need to use them in such scenarios please consider that some of its objects like NSManagedContext and NSManagedObject are single threaded. 


Remember the Movies
-------------------
With all the possibilities today for watching a movie (Streaming, Online Rent, Physical Rent, Theaters, etc) some times we can forget if we have already watched a movie or in another way remember those recommendations of friends and family. Lets create an app for that! (Using Core Data ;)


Core Data Model
~~~~~~~~~~~~~~~

Please create a new project called **Remember the Movies**:

[source, sh]
------------
$ motion create "Remember the Movies"

$ cd "Remember the Movies"

$ cd app

$ mkdir extensions
------------

Before we can start coding our project is needed for us to copy some Core Data Object extensions, these extensions are designed to make our Core Data implementation more easy and simple. Please copy all the files from **resources/extensions** to our **extensions folder**

Now is time to code our model for the app, starting with the **Director** object:

[source, sh]
------------

$ mkdir model

$ cd model

$ touch director.rb

$ open director.rb
------------

[source, ruby]
--------------
# Please note that the Director Model object is child
# of the class NSManagedObject
class Director < NSManagedObject

  # Core Data attributes for the object, this attributes will be used
  # for all the operations like Persisting and Searching
  @attributes ||= [

    # We have to define the names and types of the attributes, also
    # you can set a default value or if it is required

    #Attribute Name, Type, Default Value, Is Optional, Is Transient, Is Indexed
    ['name', NSStringAttributeType, '', false, false, false]
  ]

end
--------------

Did you notice that our **Director model** is child of **NSManagedObject**? Core Data needs to add some methods to the object so it can work with it, so the way that these work is using inheritance, according to these every object that we want Core Data to track must inherit from NSManagedObject

Lets continue creating the **Movie** model class:

[source, sh]
------------
$ touch movie.rb

$ open movie.rb
------------

[source, ruby]
--------------
class Movie < NSManagedObject

  # Core Data attributes for the object, this attributes will be used
  # for all the operations like Persisting and Searching
  @attributes ||= [

    # We have to define the names and types of the attributes, also
    # you can set a default value or if it is required

    #Attribute Name, Type, Default Value, Is Optional, Is Transient, Is Indexed
    ['name', NSStringAttributeType, '', false, false, false],
    ['release_year', NSInteger32AttributeType, 0, false, false, false],
    ['studio', NSStringAttributeType, '', false, false, false]

  ]

end
--------------

Yes! Now we got a object for representing the Movie, but as you already notice the attributes can have many types. The more important ones are:

. NSInteger32AttributeType
. NSDoubleAttributeType
. NSStringAttributeType
. NSBooleanAttributeType
. NSDateAttributeType
. NSBinaryDataAttributeType

Now lets add an a relationship between the **Director** and the **Movie**, for these we need to edit both files:

[source, sh]
------------
$ open movie.rb
------------

["source", "ruby", args="-O \"hl_lines=17 18 19 20 21 22 23 24 25 26 27 28 29\""]
--------------------------------------------
class Movie < NSManagedObject

  # Core Data attributes for the object, this attributes will be used
  # for all the operations like Persisting and Searching
  @attributes ||= [

    # We have to define the names and types of the attributes, also
    # you can set a default value or if it is required

    #Attribute Name, Type, Default Value, Is Optional, Is Transient, Is Indexed
    ['name', NSStringAttributeType, '', false, false, false],
    ['release_year', NSInteger32AttributeType, 0, false, false, false],
    ['studio', NSStringAttributeType, '', false, false, false]

  ]

  # In Core Data we can have relationship between objects, so lets add one 
  # to the Director Object
  @relationships ||= [

    # IMPORTANT: In Core Data is required to have a circular relationships between
    # the two objects. In these case we are adding a Relationship from Movie to Director
    # but also we will need one from Director to Movie, these relationship is called Inverse
    # Relationship
    
    # Relationship Name, Relationship Class, Inverse Relationship, Is Optional, Is Indexed, 
    # Is Ordered, Min Count, Max Count, Delete Rule
    ['director', 'Director', 'movie', true, false, true, 0, 1, NSNullifyDeleteRule]
  ]

end
--------------------------------------------

IMPORTANT: The relationships in Core Data are circular, what these means is that if we want to create a relationship from Movie to Director we also need another one from Director to Movie

Based on these lets open our Director class to add the Inverse Relationship:

[source, sh]
------------
$ open director.rb
------------

["source", "ruby", args="-O \"hl_lines=17 18 19 20 21 22 23 24 25 26 27\""]
--------------------------------------------
# Please note that the Director Model object is child
# of the class NSManagedObject
class Director < NSManagedObject

  # Core Data attributes for the object, this attributes will be used
  # for all the operations like Persisting and Searching
  @attributes ||= [

    # We have to define the names and types of the attributes, also
    # you can set a default value or if it is required

    #Attribute Name, Type, Default Value, Is Optional, Is Transient, Is Indexed
    ['name', NSStringAttributeType, '', false, false, false]
  ]


  # In Core Data we can have relationship between objects, so lets add one 
  # to the Movie Object
  @relationships ||= [

    # IMPORTANT: In Core Data is required to have a circular relationships between
    # the two objects. So lets create the inverse relationship from Director to Movie 
    
    # Relationship Name, Relationship Class, Inverse Relationship, Is Optional, Is Indexed, 
    # Is Ordered, Min Count, Max Count, Delete Rule
    ['movie', 'Movie', 'director', true, false, true, 0, NSIntegerMax, NSCascadeDeleteRule]
  ]

end
--------------------------------------------

Continuing on the app lets open our **app_delegate.rb** and add the following:

[source, ruby]
--------------
class AppDelegate

  # Lets keep all of our Core Data Objects in here
  ManageObjectClases = [Director, Movie]

  def application(application, didFinishLaunchingWithOptions:launchOptions)
    
    initialize_core_data

    true
  end


  def initialize_core_data

    # First we need to create the NSManagedObjectModel with
    # all the entities and their relationships. You can think of 
    # these object as a reference of the objects for Core Data 
    # to use
    managed_object_model = NSManagedObjectModel.alloc.init
    managed_object_model.entities = ManageObjectClases.collect { |c| c.entity }
    managed_object_model.entities.each { |entity| entity.wireRelationships }

    # The next object needed is the NSPersistentStoreCoordinator
    # which will allow Core Data to persist the information.
    #
    # IMPORT: The NSPersistentStoreCoordinator is not the file or 
    # the database, is just the enabler to write on them
    persistent_store_coordinator = NSPersistentStoreCoordinator.alloc.initWithManagedObjectModel(managed_object_model)
    
    # Now lets get a URL for where do we want Core Data to create
    # the persist file, in this case a SQLite Database File
    persistent_store_file_url = NSURL.fileURLWithPath(File.join(NSHomeDirectory(), 
                                                                'Documents', 
                                                                'RememberTheMovies.sqlite'))


    error_pointer = Pointer.new(:object)

    # Add a new Persistent Store to our Persistent Store Coordinator
    # which these means is that we are telling the Persistent Store 
    # Coordinator where to perform the save of our objects.
    #
    # In these case we are setting that our objects must be stored in
    # a SQLite database in the path we already created previously
    unless persistent_store_coordinator.addPersistentStoreWithType(NSSQLiteStoreType,
                                                                   configuration: nil,
                                                                   URL: persistent_store_file_url,
                                                                   options: nil,
                                                                   error: error_pointer)

      # In case that we can't initialize the Persistance Store File
      raise "Can not initialize Core Data Persistance Store Coordinator: #{error_pointer[0].description}"
    end

    # Finally our most important object the Managed Object Context
    # this object is the responsible for creating, destroying and 
    # fetching the objects
    #
    # Of course for it to work we need to assign who is coordinating
    # the object persistence
    @managed_object_context = NSManagedObjectContext.alloc.init
    @managed_object_context.persistentStoreCoordinator = persistent_store_coordinator
  end

end
--------------

Great! With these code we initialize Core Data in our app using Sqlite as persistence and adding our new Model Objects to it

The final step is to add the **Core Data Framework** to our project, this is done editing the **RakeFile**:

[source, sh]
------------
$ cd ..

$ open RakeFile
------------

["source", "ruby", args="-O \"hl_lines=9\""]
--------------
# -*- coding: utf-8 -*-
$:.unshift("/Library/RubyMotion/lib")
require 'motion/project'

Motion::Project::App.setup do |app|
  # Use `rake config' to see complete project settings.
  app.name = 'Remember the Movies'

  app.frameworks += ['CoreData']
end
--------------

If we run our app you should see the following:

.Initial Core Data Set Up
image::resources/ch24-CoreData/ch24_InitialCoreData.png[Initial Core Data Set Up]

IMPORTANT: If you make some changes to the Model objects after you initialize the Core Data Persistent Store, its needed to clean the project using **rake clean** and reset the content and settings of the simulator using the **iOS Simulator** menu


Some Views for Some Records
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Lets start adding some view controllers to our app so we can visualize and add new data, lets begin creating a new view controller called **movies_view_controller.rb**:

[source, sh]
------------
$ cd app

$ mkdir controllers

$ cd controllers

$ touch movies_view_controller.rb

$ open movies_view_controller.rb
------------  

[source, ruby]
--------------
class MoviesViewController < UIViewController

  attr_accessor :managed_object_context

  def loadView

    # Create a new Bar Button Item with the Add System Default
    add_movie_bar_button_item = UIBarButtonItem.alloc.initWithBarButtonSystemItem(UIBarButtonSystemItemAdd,
                                                                                  target: self,
                                                                                  action: 'add_new_movie')

    # Add the Bar Button Item to the Navigation Bar
    self.navigationItem.rightBarButtonItem = add_movie_bar_button_item
  end

end
--------------

Lets load our new controller into the window, please open the **app_delegate.rb** file:

[source, sh]
------------
$ cd ..

$ open app_delegate.rb
------------

["source", "ruby", args="-O \"hl_lines=5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\""]
------------------
def application(application, didFinishLaunchingWithOptions:launchOptions)

  initialize_core_data

  # Create a new instance of our Movies View Controller
  movies_view_controller = MoviesViewController.alloc.init

  # We need to pass the Managed Object Context to the next controller
  # so we can use it later for creating, fetching or deleting objects
  movies_view_controller.managed_object_context = @managed_object_context


  # Add it as a root view controller of a UINavigationController
  navigation_controller = UINavigationController.alloc.initWithRootViewController(movies_view_controller)

  # Create a new UIWindow and add our UINavigationController to it
  @window = UIWindow.alloc.initWithFrame(UIScreen.mainScreen.bounds)
  @window.rootViewController = navigation_controller
  @window.makeKeyAndVisible

  true
end
------------------

If we run our app we should se the following:

.Initial Movies View Controller
image::resources/ch24-CoreData/ch24_InitialMoviesViewController.png[Initial Movies View Controller]

Awesome! The next step is to create a new view controller called **Add Movie View Controller**:

[source, sh]
------------
$ cd controllers

$ touch add_movie_view_controller.rb

$ open add_movie_view_controller.rb
------------

[source, ruby]
--------------
class AddMovieViewController < UITableViewController

  attr_accessor :managed_object_context

  def loadView

    # Set up the title for the View Controller
    self.title = 'Add Movie'

    # Create a new Table View for showing the Text Fields
    table_view = UITableView.alloc.initWithFrame(UIScreen.mainScreen.bounds,
                                                 style:UITableViewStyleGrouped)

    # Set up the view controller as a Data Source
    # of the table view
    table_view.dataSource = self

    # Add the table view as view of the view controller
    self.view = table_view
  end


  # UITableView Data Source

  def numberOfSectionsInTableView(tableView)

    # Lets set two sections one for the Movie General
    # Data and another for a list of Directors
    2
  end


  def tableView(tableView, titleForHeaderInSection: section)

    # Create a new variable to store our header title
    title_for_header = ''


    # If the section is the Directors One
    if section == 1

      # Set the title to the title variable
      title_for_header = 'Choose a Director...'
    end

    # Return the title variable
    title_for_header
  end


  def tableView(tableView, numberOfRowsInSection: section)

    # Lets create a new instance variable for storing 
    # the number of rows in the section
    number_of_rows = 0

    # If the section is General Data
    if section == 0

      # We need two rows
      number_of_rows = 2

    else

      # If the section is Directors we need only one
      number_of_rows = 1

    end

    # Return the number of rows for the section
    number_of_rows
  end


  def tableView(tableView, cellForRowAtIndexPath: indexPath)

    # If the section is General Data
    if indexPath.section == 0

      # Return a General Data Cell
      general_information_cell_for_table_view(tableView, index_path: indexPath)
    else

      # Return a Add Director Cell
      add_director_cell_for_table_view(tableView)
    end
  end


  def general_information_cell_for_table_view(tableView, index_path: index_path)

    # Create a cell identifier for the General Information Cell
    cell_identifier = 'GeneralInformationCell'

    # Dequeue a cell with the identifier
    cell = tableView.dequeueReusableCellWithIdentifier(cell_identifier)


    # If we are not cells to use we need to create one
    if cell == nil

      # Lets create a new UITableViewCell with the identifier
      cell = UITableViewCell.alloc.initWithStyle(UITableViewCellStyleDefault, reuseIdentifier:cell_identifier)
      cell.selectionStyle = UITableViewCellSelectionStyleNone

      # Instantiate a new UITextField for editing some values
      cell_text_field = UITextField.alloc.initWithFrame(CGRectMake(100, 11, 200, 30))
      cell_text_field.autocorrectionType = UITextAutocorrectionTypeNo;
      cell_text_field.textColor = UIColor.colorWithRed(0.235, green:0.325, blue:0.506, alpha:1.000)

      # Set the view controller as delegate of the Text Field
      cell_text_field.delegate = self

      # Add the Text Field into the cell view
      cell.addSubview(cell_text_field)

      # If the row is the first one
      if index_path.row == 0
 
        cell_text_field.placeholder = 'Required'

        # Assign the cell_text_field as name_text_field
        @name_text_field = cell_text_field      
      else

        cell_text_field.placeholder = 'Optional'

        # Assign the cell_text_field as release_year_text_field
        @release_year_text_field = cell_text_field  
      end
    end


    # If the row is the first one
    if index_path.row == 0

      # Set the title to Name
      cell.textLabel.text = 'Name'
    else

      # Else set the title to Year
      cell.textLabel.text = 'Year'
    end

    cell
  end


  def add_director_cell_for_table_view(tableView)

    #Create a cell identifier for the Add Director Cell
    cell_identifier = 'AddDirectorCell'

    # Dequeue a cell with the identifier
    cell = tableView.dequeueReusableCellWithIdentifier(cell_identifier)


    # If we are not cells to use we need to create one
    if cell == nil

      # Lets create a new UITableViewCell with the identifier
      cell = UITableViewCell.alloc.initWithStyle(UITableViewCellStyleDefault, reuseIdentifier:cell_identifier)
      cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator
    end

    # Add text to the cell
    cell.textLabel.text = 'Add Director...'

    cell
  end


  # UITextField Delegate
  def textFieldShouldReturn(textField)

    # Resign the UITextField as first responder to hide
    # the keyboard
    textField.resignFirstResponder

    true
  end


end
--------------

Great now that we have our **add_movie_view_controller.rb** lets  present it using our **movies_view_controller.rb**, so lets open it and add the following method:

[source, sh]
------------
$ open movies_view_controller.rb
------------

[source, ruby]
--------------
def add_new_movie

  # Create a new AddMovieViewController
  add_movie_view_controller = AddMovieViewController.alloc.init

  # We need to pass the Managed Object Context to the next controller
  # so we can use it later for creating, fetching or deleting objects
  add_movie_view_controller.managed_object_context = @managed_object_context 


  # Push it using the Navigation Controller
  self.navigationController.pushViewController(add_movie_view_controller, 
                                               animated:true)
end
--------------

Now if we run the app and select the plus button we should see the following:

.Initial Add Movie View Controller
image::resources/ch24-CoreData/ch24_InitialAddMovieViewController.png[Initial Add Movie View Controller]

Before we can start adding movies is required to add a Director first, so lets create a view controller called **add_director_view_controller.rb** for this task:

[source, sh]
------------
$ touch add_director_view_controller.rb

$ open add_director_view_controller.rb
------------

[source, ruby]
--------------
class AddDirectorViewController < UITableViewController

  attr_accessor :managed_object_context

  def loadView

    # Set up the title for the View Controller
    self.title = 'Add Director'

    # Create a new Table View for showing the Text Fields
    table_view = UITableView.alloc.initWithFrame(UIScreen.mainScreen.bounds,
                                                 style:UITableViewStyleGrouped)

    # Set up the view controller as a Data Source
    # of the table view
    table_view.dataSource = self

    # Add the table view as view of the view controller
    self.view = table_view
  end


  # UITableView Data Source

  def tableView(tableView, numberOfRowsInSection: section)

    # Because the Director only has one attribute, we only
    # need one cell
    1
  end


  def tableView(tableView, cellForRowAtIndexPath: indexPath)

    # Create a cell identifier for the General Information Cell
    cell_identifier = 'GeneralInformationCell'

    # Dequeue a cell with the identifier
    cell = tableView.dequeueReusableCellWithIdentifier(cell_identifier)


    # If we are not cells to use we need to create one
    if cell == nil

      # Lets create a new UITableViewCell with the identifier
      cell = UITableViewCell.alloc.initWithStyle(UITableViewCellStyleDefault, reuseIdentifier:cell_identifier)
      cell.selectionStyle = UITableViewCellSelectionStyleNone

      # Instantiate a new UITextField for editing the name of the 
      # new director
      @name_text_field = UITextField.alloc.initWithFrame(CGRectMake(100, 11, 200, 30))
      @name_text_field.autocorrectionType = UITextAutocorrectionTypeNo;
      @name_text_field.placeholder = 'Required'
      @name_text_field.textColor = UIColor.colorWithRed(0.235, green:0.325, blue:0.506, alpha:1.000)

      # Set the view controller as delegate of the Text Field
      @name_text_field.delegate = self

      # Add the Text Field into the cell view
      cell.addSubview(@name_text_field)

    end


    # Set the title to Name
    cell.textLabel.text = 'Name'

    cell
  end


  # UITextField Delegate
  def textFieldShouldReturn(textField)

    # Resign the UITextField as first responder to hide
    # the keyboard
    textField.resignFirstResponder

    true
  end

end
--------------

Great! The only thing left to do is present the **add_director_view_controller.rb** when the user select the **Add Director..** cell. For this we need to open our **add_movie_view_controller.rb** and edit the following:

[source, sh]
------------
$ open add_movie_view_controller.rb
------------


["source", "ruby", args="-O \"hl_lines=14 15 16\""]
--------------
def loadView

  # Set up the title for the View Controller
  self.title = 'Add Movie'

  # Create a new Table View for showing the Text Fields
  table_view = UITableView.alloc.initWithFrame(UIScreen.mainScreen.bounds,
                                               style:UITableViewStyleGrouped)

  # Set up the view controller as a Data Source
  # of the table view
  table_view.dataSource = self

  # Set up the view controller as a Delegate
  # of the table view
  table_view.delegate = self

  # Add the table view as view of the view controller
  self.view = table_view
end


# UITableView Delegate

def tableView(tableView, didSelectRowAtIndexPath: indexPath)

  # If the section is the Directors one
  if indexPath.section == 1 

    # Create a new AddDirectorViewController
    add_director_view_controller = AddDirectorViewController.alloc.init

    # We need to pass the Managed Object Context to the next controller
    # so we can use it later for creating, fetching or deleting objects
    add_director_view_controller.managed_object_context = @managed_object_context 

    # Push it using the Navigation Controller
    self.navigationController.pushViewController(add_director_view_controller, 
                                                 animated:true)
  end

end
--------------

Now our **AddDirectorViewController** is visible:

.Initial Add Director View Controller
image::resources/ch24-CoreData/ch24_InitialAddDirectorViewController.png[Initial Add Director View Controller]


New Objects
~~~~~~~~~~~
Lets create our first Core Data Object in this case **Director**, please open your **add_director_view_controller.rb**:

[source, sh]
------------
$ open add_director_view_controller.rb
------------

["source", "ruby", args="-O \"hl_lines=17 18 19 20 21 22 23 24 25 26 27 28\""]
--------------
def loadView

  # Set up the title for the View Controller
  self.title = 'Add Director'

  # Create a new Table View for showing the Text Fields
  table_view = UITableView.alloc.initWithFrame(UIScreen.mainScreen.bounds,
                                               style:UITableViewStyleGrouped)

  # Set up the view controller as a Data Source
  # of the table view
  table_view.dataSource = self

  # Add the table view as view of the view controller
  self.view = table_view

  # Add new Bar Button Item to the Navigation Bar for saving
  save_bar_button_item = UIBarButtonItem.alloc.initWithTitle('Save',
                                                             style: UIBarButtonItemStyleDone,
                                                             target: self,
                                                             action: 'save_new_director')

  # Add the Bar Button Item to the Navigation Bar
  self.navigationItem.rightBarButtonItem = save_bar_button_item

  # Disable the Save button until the user add some text
  # into the UITextView
  self.navigationItem.rightBarButtonItem.enabled = false;
end


def save_new_director

  # Using Core Data create a new instance of the object Director
  director = NSEntityDescription.insertNewObjectForEntityForName(Director.name, 
                                                                 inManagedObjectContext: @managed_object_context)

  # Assign the text of the UITextField to the director name
  director.name = @name_text_field.text


  # Create a new pointer for managing the errors
  error_pointer = Pointer.new(:object)

  # Lets persist the new Director object, saving the managed
  # object context that contains it
  unless @managed_object_context.save(error_pointer)

    # In case we can not save it
    raise "Error saving a new Director: #{error_pointer[0].description}"
  end

  # Pop the Director View Controller
  self.navigationController.popViewControllerAnimated(true)
end


def textField(textField, shouldChangeCharactersInRange: range, replacementString: string)

  # Calculate the final length of the text in the UITextField
  text_length = textField.text.length + string.length - range.length


  # If the length of the text is greater than 0
  if text_length > 0

    # Enable the save button
    self.navigationItem.rightBarButtonItem.enabled = true;
  else

    # Else disable the save button
    self.navigationItem.rightBarButtonItem.enabled = false;
  end

  true
end
--------------

Now we are saving a new Director! 

.Save a new Director
image::resources/ch24-CoreData/ch24_SaveANewDirector.png[Save a new Director]

At least on theory right? If we select the save button we return to the previous screen but we are not seeing any directors added yet. Lets implement these part in our **add_movie_view_controller.rb**:

[source, sh]
------------
$ open add_movie_view_controller.rb
------------

["source", "ruby", args="-O \"hl_lines=3 4 97 98 99 100 116 117 118 119 120 121 122 123 124 125 126 127 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182\""]
--------------
def loadView

  #For security lets set up the fetched_directors array
  @fetched_directors = []

  # Set up the title for the View Controller
  self.title = 'Add Movie'

  # Create a new Table View for showing the Text Fields
  table_view = UITableView.alloc.initWithFrame(UIScreen.mainScreen.bounds,
                                               style:UITableViewStyleGrouped)

  # Set up the view controller as a Data Source
  # of the table view
  table_view.dataSource = self

  # Set up the view controller as a Delegate
  # of the table view
  table_view.delegate = self

  # Add the table view as view of the view controller
  self.view = table_view


  # Add new Bar Button Item to the Navigation Bar for saving
  save_bar_button_item = UIBarButtonItem.alloc.initWithTitle('Save',
                                                             style: UIBarButtonItemStyleDone,
                                                             target: self,
                                                             action: 'save_new_movie')

  # Add the Bar Button Item to the Navigation Bar
  self.navigationItem.rightBarButtonItem = save_bar_button_item

  # Disable the Save button until the user add some text
  # into the text views and select a Director from the list
  self.navigationItem.rightBarButtonItem.enabled = false;
end


def viewWillAppear(animated)

  super

  # Using a NSFetchRequest object we can ask Core Data
  # to fetch specific objects
  fetch_request = NSFetchRequest.alloc.init

  # We need a NSEntityDescription for the Director object
  # so we can tell Core Data which entity we want to 
  # retrieve
  director_entity = NSEntityDescription.entityForName(Director.name, 
                                                      inManagedObjectContext:@managed_object_context)
  fetch_request.setEntity(director_entity)

  # Sort the directors by their "name" attribute
  fetch_sort = NSSortDescriptor.alloc.initWithKey('name',
                                                  ascending: true)
  fetch_request.setSortDescriptors([fetch_sort])


  # Create a new pointer for managing the errors
  error_pointer = Pointer.new(:object)

  # Using the NSManagedObjectContext execute the fetch
  # request
  @fetched_directors = @managed_object_context.executeFetchRequest(fetch_request,
                                                                   error: error_pointer)

  # If the returning array of the fetch request is nil
  # means that a problem has occured
  unless @fetched_directors

    # In case we can not fetch the directors
    raise "Error fetching Directors: #{error_pointer[0].description}"

  end

  # Ask the table view to reload its data
  self.view.reloadData
end


def tableView(tableView, numberOfRowsInSection: section)

  # Lets create a new instance variable for storing 
  # the number of rows in the section
  number_of_rows = 0

  # If the section is General Data
  if section == 0

    # We need two rows
    number_of_rows = 2

  else

    # If the section is Directors we need to add one more
    # to the total of directors fetched because the need of
    # the 'Add Director...' cell
    number_of_rows = @fetched_directors.count + 1
  end

  # Return the number of rows for the section
  number_of_rows
end


def tableView(tableView, cellForRowAtIndexPath: indexPath)

  # If the section is General Data
  if indexPath.section == 0

    # Return a General Data Cell
    general_information_cell_for_table_view(tableView, index_path: indexPath)

  # If the section is Directors but is not the 'Add Director...'
  # cell, remember we are adding + 1 to the total fetched directors 
  # count
  elsif indexPath.section == 1 && indexPath.row < @fetched_directors.count

    # Return a Director Cell
    director_cell_for_table_view(tableView, index_path: indexPath)
  else

    # Return a Add Director Cell
    add_director_cell_for_table_view(tableView)
  end
end


def director_cell_for_table_view(tableView, index_path: index_path)

  #Create a cell identifier for the Director Cell
  cell_identifier = 'DirectorCell'

  # Dequeue a cell with the identifier
  cell = tableView.dequeueReusableCellWithIdentifier(cell_identifier)


  # If we are not cells to use we need to create one
  if cell == nil

    # Lets create a new UITableViewCell with the identifier
    cell = UITableViewCell.alloc.initWithStyle(UITableViewCellStyleDefault, reuseIdentifier:cell_identifier)
  end

  # Get the fetched director from the array
  director = @fetched_directors[index_path.row]

  # Add the director name to the cell
  cell.textLabel.text = director.name

  cell
end


# UITableView Delegate

def tableView(tableView, didSelectRowAtIndexPath: indexPath)

  # If the section is the Directors one and the cell is the
  # 'Add Director...' one
  if indexPath.section == 1  && indexPath.row > @fetched_directors.count - 1

    # Create a new AddDirectorViewController
    add_director_view_controller = AddDirectorViewController.alloc.init

    # We need to pass the Managed Object Context to the next controller
    # so we can use it later for creating, fetching or deleting objects
    add_director_view_controller.managed_object_context = @managed_object_context 

    # Push it using the Navigation Controller
    self.navigationController.pushViewController(add_director_view_controller, 
                                                 animated:true)

  # If the section is Directors but is not the 'Add Director...'
  # cell, remember we are adding + 1 to the total fetched directors 
  # count
  elsif indexPath.section == 1 && indexPath.row < @fetched_directors.count 

    @selected_director = @fetched_directors[indexPath.row] 
  end

end
--------------

Yes! If we run our app again we should see now all the directors loaded into the **add_movie_view_controller.rb** table view

.Loaded Directors
image::resources/ch24-CoreData/ch24_LoadedDirectors.png[Loaded Directors]

Finally in these part it will be creating the new movie on our **add_movie_view_controller.rb**, please open it:

[source, sh]
------------
$ open add_movie_view_controller.rb
------------


["source", "ruby", args="-O \"hl_lines=22 23 24 25 26 27 28 29 30 31 32 33 125 126 127 128 129 130\""]
--------------
def loadView

  # Set up the title for the View Controller
  self.title = 'Add Movie'

  # Create a new Table View for showing the Text Fields
  table_view = UITableView.alloc.initWithFrame(UIScreen.mainScreen.bounds,
                                               style:UITableViewStyleGrouped)

  # Set up the view controller as a Data Source
  # of the table view
  table_view.dataSource = self

  # Set up the view controller as a Delegate
  # of the table view
  table_view.delegate = self

  # Add the table view as view of the view controller
  self.view = table_view


  # Add new Bar Button Item to the Navigation Bar for saving
  save_bar_button_item = UIBarButtonItem.alloc.initWithTitle('Save',
                                                             style: UIBarButtonItemStyleDone,
                                                             target: self,
                                                             action: 'save_new_movie')

  # Add the Bar Button Item to the Navigation Bar
  self.navigationItem.rightBarButtonItem = save_bar_button_item

  # Disable the Save button until the user add some text
  # into the text views and select a Director from the list
  self.navigationItem.rightBarButtonItem.enabled = false;
end


def save_new_movie

  # Using Core Data create a new instance of the object Movie
  movie = NSEntityDescription.insertNewObjectForEntityForName(Movie.name, 
                                                              inManagedObjectContext: @managed_object_context)

  # Assign the text of the name text field to the movie
  # name
  movie.name = @name_text_field.text

  if @release_year_text_field.text != nil

    # Assign the text of the year text field to the movie
    # year
    movie.release_year = @release_year_text_field.text.intValue
  end

  # Assign the selected director to the movie
  movie.director = @selected_director

  # Create a new pointer for managing the errors
  error_pointer = Pointer.new(:object)

  # Lets persist the new Movie object, saving the managed
  # object context that contains it
  unless @managed_object_context.save(error_pointer)

  # In case we can not save it
   raise "Error saving a new Movie: #{error_pointer[0].description}"
  end

  # Pop the Movie View Controller
  self.navigationController.popViewControllerAnimated(true)
end


def textField(textField, shouldChangeCharactersInRange: range, replacementString: string)

  # If the changing text field is the name one and there is already
  # selected a Director from the list
  if textField == @name_text_field && @selected_director != nil

    # Calculate the final length of the text in the UITextField
    text_length = textField.text.length + string.length - range.length


    # If the length of the text is greater than 0
    if text_length > 0

      # Enable the save button
      self.navigationItem.rightBarButtonItem.enabled = true;
    else

      # Else disable the save button
      self.navigationItem.rightBarButtonItem.enabled = false;
    end
  end

  true
end


# UITableView Delegate

def tableView(tableView, didSelectRowAtIndexPath: indexPath)

  # If the section is the Directors one and the cell is the
  # 'Add Director...' one
  if indexPath.section == 1 && indexPath.row > @fetched_directors.count - 1 

    # Create a new AddDirectorViewController
    add_director_view_controller = AddDirectorViewController.alloc.init

    # We need to pass the Managed Object Context to the next controller
    # so we can use it later for creating, fetching or deleting objects
    add_director_view_controller.managed_object_context = @managed_object_context 

    # Push it using the Navigation Controller
    self.navigationController.pushViewController(add_director_view_controller, 
                                                 animated:true)

    # If the section is Directors but is not the 'Add Director...'
    # cell, remember we are adding + 1 to the total fetched directors 
    # count
  elsif indexPath.section == 1 && indexPath.row < @fetched_directors.count 

    @selected_director = @fetched_directors[indexPath.row]

    # If the length of the text is greater than 0
    if @name_text_field.text != nil && @name_text_field.text.length > 0

      # Enable the save button
      self.navigationItem.rightBarButtonItem.enabled = true;
    end
  end

end
--------------

Now the movie save is also working! So we can continue to the last part of the exercise: Searching and Deleting

.Save a new Movie
image::resources/ch24-CoreData/ch24_SaveANewMovie.png[Save a new Movie]

Search and Destroy
~~~~~~~~~~~~~~~~~~
Finally we can work on our **movies_view_controller.rb**, the first thing that we should do is to add a UITableViewController to it and load the **Movie** objects into it:

[source, sh]
------------
$ open movies_view_controller.rb
------------

["source", "ruby", args="-O \"hl_lines=3 4 5 6 7 8 9 10 11 12 13 14 15 16\""]
--------------
def loadView

  # Set up the title for the View Controller
  self.title = 'Movies'

  # Create a new Table View for showing the Text Fields
  table_view = UITableView.alloc.initWithFrame(UIScreen.mainScreen.bounds,
                                               style:UITableViewStyleGrouped)

  # Set up the view controller as a Data Source
  # of the table view
  table_view.dataSource = self


  # Add the table view as view of the view controller
  self.view = table_view


  # Create a new Bar Button Item with the Add System Default
  add_movie_bar_button_item = UIBarButtonItem.alloc.initWithBarButtonSystemItem(UIBarButtonSystemItemAdd,
                                                                                target: self,
                                                                                action: 'add_new_movie')

  # Add the Bar Button Item to the Navigation Bar
  self.navigationItem.rightBarButtonItem = add_movie_bar_button_item
end


def viewWillAppear(animated)

  super

  # Fetch the movies from Core Data and update
  # the table view
  reload_data
end


def reload_data

  # Using a NSFetchRequest object we can ask Core Data
  # to fetch specific objects
  fetch_request = NSFetchRequest.alloc.init

  # We need a NSEntityDescription for the Movie object
  # so we can tell Core Data which entity we want to 
  # retrieve
  director_entity = NSEntityDescription.entityForName(Movie.name, 
                                                      inManagedObjectContext:@managed_object_context)
  fetch_request.setEntity(director_entity)

  # Sort the movies by their "name" attribute
  fetch_sort = NSSortDescriptor.alloc.initWithKey('name',
                                                  ascending: true)
  fetch_request.setSortDescriptors([fetch_sort])

  # Update the fetch movies array and reload the table view
  update_fetched_movies_with_fetch_request(fetch_request)
end


def update_fetched_movies_with_fetch_request(fetch_request)

  # Create a new pointer for managing the errors
  error_pointer = Pointer.new(:object)

  # Using the NSManagedObjectContext execute the fetch
  # request
  @fetched_movies = @managed_object_context.executeFetchRequest(fetch_request,
                                                                error: error_pointer)

  # If the returning array of the fetch request is nil
  # means that a problem has occured
  unless @fetched_movies

    # In case we can not fetch the directors
    raise "Error fetching Movies: #{error_pointer[0].description}"

  end
  
  # Ask the table view to reload its data
  self.view.reloadData
end


# UITableView Data Source

def tableView(tableView, numberOfRowsInSection: section)

  # Return the count of the fetched movies 
  @fetched_movies.count
end


def tableView(tableView, cellForRowAtIndexPath: indexPath)

  # Create a cell identifier for the Movie Cell
  cell_identifier = 'MovieCell'

  # Dequeue a cell with the identifier
  cell = tableView.dequeueReusableCellWithIdentifier(cell_identifier)


  # If we are not cells to use we need to create one
  if cell == nil

    # Lets create a new UITableViewCell with the identifier
    cell = UITableViewCell.alloc.initWithStyle(UITableViewCellStyleValue1, reuseIdentifier:cell_identifier)
    cell.selectionStyle = UITableViewCellSelectionStyleNone
  end


  # Get the fetched movie from the array
  movie = @fetched_movies[indexPath.row]

  # Set the title to the movie name
  cell.textLabel.text = movie.name

  # Set the detail text label to the movie director name
  cell.detailTextLabel.text = movie.director.name

  cell
end
--------------

Great now we can see the movies that we already add in the **add_movie_view_controller.rb**

.Loaded Movies
image::resources/ch24-CoreData/ch24_LoadedMovies.png[Loaded Movies]

Now is time to add some search functionality:

["source", "ruby", args="-O \"hl_lines=11 12 13 14 15 16 17 18\""]
--------------
def loadView

  # Set up the title for the View Controller
  self.title = 'Movies'

  # Create a new Table View for showing the Text Fields
  table_view = UITableView.alloc.initWithFrame(UIScreen.mainScreen.bounds,
                                               style:UITableViewStyleGrouped)


  # Create a new Search Bar for the user to add some text
  @search_bar = UISearchBar.alloc.initWithFrame(CGRectMake(0, 70, 320, 44))

  # Set its delegate to movies view controller
  @search_bar.delegate = self

  # Add the Search Bar to the table view header
  table_view.setTableHeaderView(@search_bar)


  # Set up the view controller as a Data Source
  # of the table view
  table_view.dataSource = self


  # Add the table view as view of the view controller
  self.view = table_view


  # Create a new Bar Button Item with the Add System Default
  add_movie_bar_button_item = UIBarButtonItem.alloc.initWithBarButtonSystemItem(UIBarButtonSystemItemAdd,
                                                                                target: self,
                                                                                action: 'add_new_movie')

  # Add the Bar Button Item to the Navigation Bar
  self.navigationItem.rightBarButtonItem = add_movie_bar_button_item
end


def searchBar(searchBar, textDidChange:searchText)

  # If the SearchBar text contains text execute the search
  # in Core Data, if not clean the search results
  if searchBar.text.length > 0

    # Using a NSFetchRequest object we can ask Core Data
    # to fetch specific objects
    fetch_request = NSFetchRequest.alloc.init

    # We need a NSEntityDescription for the Movie object
    # so we can tell Core Data which entity we want to 
    # retrieve
    director_entity = NSEntityDescription.entityForName(Movie.name, 
                                                        inManagedObjectContext:@managed_object_context)
    fetch_request.setEntity(director_entity)

    # Sort the movies by their "name" attribute
    fetch_sort = NSSortDescriptor.alloc.initWithKey('name',
                                                    ascending: true)
    fetch_request.setSortDescriptors([fetch_sort])


    # Create a predicate for our search query, in this case we want 
    # every Movie that contains in the name or in the Directors name
    # the UISearchBar text
    fetch_predicate = NSPredicate.predicateWithFormat("name contains[cd] %@ OR director.name contains[cd] %@", 
                                                      argumentArray:[searchBar.text, searchBar.text])

    # Add the predicate to our NSFetchRequest
    fetch_request.predicate = fetch_predicate

    # Update the fetch movies array and reload the table view
    update_fetched_movies_with_fetch_request(fetch_request)

  else

    # Reload all the movies
    reload_data
  end
end
--------------

Awesome! Now it search by the Movie Name and the Director Name

.Search Movies
image::resources/ch24-CoreData/ch24_SearchMovies.png[Search Movies]

The only feature left is the delete one, lets implement it adding the following methods to our **movies_view_controller.rb** file:

[source, ruby]
--------------
def tableView(tableView, canEditRowAtIndexPath: indexPath)

  true
end


def tableView(tableView, commitEditingStyle: editingStyle, forRowAtIndexPath: indexPath)

  # Get the fetched movie from the array
  movie = @fetched_movies[indexPath.row]

  # Ask the NSManagedObjectContext to delete the object
  @managed_object_context.deleteObject(movie)

  # Create a new pointer for managing the errors
  error_pointer = Pointer.new(:object)

  # Lets persist the deleted Movie object, saving the managed
  # object context that contains it
  unless @managed_object_context.save(error_pointer)

    # In case we can not save it
    raise "Error deleting a Movie: #{error_pointer[0].description}"
  end   


  # Create a new mutable copy of the fetched_movies array
  mutable_fetched_movies = @fetched_movies.mutableCopy
  
  # Remove the movie from the array
  mutable_fetched_movies.delete(movie)

  # Assign the modified array to our fetched_movies property
  @fetched_movies = mutable_fetched_movies

  # Tell the table view to delete the row
  tableView.deleteRowsAtIndexPaths([indexPath], 
                                   withRowAnimation:UITableViewRowAnimationFade)
end
--------------

.Delete Movies
image::resources/ch24-CoreData/ch24_DeleteMovies.png[Delete Movies]

Now is finish! In the exercise we look on how to add Model Objects into Core Data, also how to create, fetch and delete instances of them.

Challenges
~~~~~~~~~~
. Add a new relationship to our **Movie** object, this time it should be the **Actor** model. Also you should modify the **add_movie_view_controller.rb** so the user can add actors to the new movies

. Create a custom cell for the **movies_view_controller.rb** so it can show the name and release year of the Movie and the name of the Director

. Add a new attribute to the **Director** object so the user can add the picture of the Director. Modify the **add_new_director.rb** accordingly
